## まとめ {#sec:type-level-programming:summary}

shapeless を用いてコードを書く際、しばしばコード中の値に依存するような対象型を探す必要が出てくる。
この関係は **依存型付け** と呼ばれている。

依存型に関連する問題は、暗黙値の探索によってうまく表現できる。暗黙値の探索により、呼び出し場所における始点の型から、中間の型を介して目的の型に辿り着くことが可能となる。

結果を計算するためには複数のステップを踏む必要があることが多い(例えば、`Repr` 型を得るために `Generic` を用い、それから他の型を得るために他の型クラスを用いる、というように)。
これを行う際は、コードがコンパイルを通って期待通りに動作することを確実にするため、いくつかのルールに従うとよいだろう:

 1. すべての中間型を型パラメータに抽出しよう。
    多くの型パラメータは結果で利用されないかもしれないが、コンパイラが照合すべき型を知るために必要となる。

 2. コンパイラは暗黙の値を左から右へと解決し、動作する組み合わせが見つからなければバックトラックを行う。
    必要となる順に暗黙のパラメータを書き、ある暗黙値とその前の暗黙値を繋ぐために1つ以上の型変数を用いるとよい。

 3. コンパイラは同時に1つの制約しか解決できないので、1つの暗黙値に対して過剰な制約を課してはならない。

 4. 他の場所で必要となるすべての型パラメータと型メンバーを指定した返り値型を明示する必要がある。
    型メンバーが重要な場合が多いので、それを保持するために、適切な場所で `Aux` 型を利用しよう。
    これらを返り値の型に明示しないと、コンパイラは暗黙値の解決をそれ以上先に進めることができなくなってしまう。

 5. `Aux` 型エイリアスを用いたパターンは、コードを読みやすく保つのに有用だ。
    Shapeless のツールボックスにある道具を使う際は `Aux` エイリアスを注意深く探し、独自の依存型付けされた関数を書く際は `Aux` エイリアスを実装するようにしよう。

有用な依存型付けされた操作の組み合わせを見つけたら、それを1つの型クラスにまとめることができる。
これは「定理(lemma)」パターンと呼ばれることがある(この用語は数学的証明から借用されたものだ)。
[@sec:ops:penultimate]節で、このパターンの例を見ていく。
